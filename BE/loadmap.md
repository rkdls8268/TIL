# Backend LoadMap✨

## 1. Programming Language
* Javascript - Node.js
* Java - Spring
* Go
* Python - Django

## 2. Network

HTTP(HyperText Transfer Protocol): HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜

TCP/IP: 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다. IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있다. TCP는 IP 위에서 동작하는 프로토콜로, 데이터의 전달을 보증하고 보낸 순서대로 받게 해준다. HTTP, FTP, SMTP 등 TCP를 기반으로 한 많은 수의 애플리케이션 프로토콜들이 IP 위에서 동작하기 때문에, 묶어서 TCP/IP로 부르기도 한다.

DNS(Domain Name System): 사람이 읽을 수 있는 도메인 이름(www.github.com)을 머신이 읽을 수 있는 IP 주소로 변환하는 시스템

Socket: 네트워크상에서 동작하는 프로그램 간 통신의 종착점. 프로그램이 네트워크에서 데이터를 통신할 수 있도록 연결해주는 연결부

## 3. [RESTful API](https://github.com/rkdls8268/TIL/blob/main/BE/nodeJs.md)

## 4. Database
RDB: 키와 값들의 간단한 관계를 테이블화시킨 매우 간단한 원칙의 전산정보 데이터베이스

- key: 테이블의 각 로우에는 저만의 고유 키가 있다. 한 테이블 안의 로우는 다른 테이블의 로우로 연결이 가능한데, 이는 연결된 로우의 고유 키를 위한 컬럼을 추가함으로써 이루어진다.
- index: 속도 향상을 목적으로 데이터 검색을 위해 사용. b-tree 구조
- SQL(Structured Query Language): 관계형 데이터베이스 관리 시스템(RDBMS)의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어
- transaction: 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위

#### 특징
- 데이터는 정해진(엄격한) 데이터 스키마(=structure)를 따라 데이터베이스 테이블에 저장된다.
- 데이터는 관계를 통해서 연결된 여러 개의 테이블에 분산된다. 

NoSQL: Not Only SQL의 약자로 기존 RDB 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미. RDB보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공.

#### 특징
- 스키마 없음
- 관계 없음

RDB에서는 정해진 스키마를 따르지 않는다면 데이터를 추가할 수 없지만, nosql에서는 다른 구조의 데이터를 같은 컬렉션(RDB에서의 테이블)에 추가할 수 있다. 
또한, 일반적으로 관련 데이터를 동일한 컬렉션에 넣는다.
따라서 여러 컬렉션에 조인할 필요없이 이미 필요한 모든 것을 갖춘 문서를 작성하게 된다.
(실제로 조인이라는 개념이 존재하지 않는다. 만약 조인을 하고 싶다면 직접 해당 외래키를 검색하여 사용할 수 있겠지만 일반적인 방법은 아니다.)

### 📌 Scaling
스케일링: 데이터베이스 서버의 확장
- 수직적 확장: 단순히 데이터베이스 서버의 성능을 향상시키는 것 (ex. CPU 업그레이드)
- 수평적 확장: 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미. 하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동.

데이터가 저장되는 방식 떄문에 RDB는 일반적으로 수직적 확장만을 지원한다. NoSQL의 경우 수평적 확장도 지원한다.

### 📌 Sharding
샤딩: 데이터를 여러 서버에 분산해서 저장하고 처리할 수 있도록 하는 기술

### 📌 RDB vs NoSQL?
어떤 데이터를 다루는지, 어떤 애플리케이션에서 사용되는지를 고려해야 한다.

RDB의 장점
- 명확하게 정의된 스키마, 데이터 무결성 보장 
- 관계는 각 데이터를 중복없이 한번만 저장

RDB의 단점
- 상대적으로 덜 유연하다. 데이터 스미카는 사전에 계획되고 알려져야 한다. (나중에 수정하기가 번거롭거나 불가능할 수도 있다.)
- 관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어질 수 있다.
- 수평적 확장이 어렵고, 대체로 수직적 확장만 가능하다. 즉, 어떤 시점에서 (처리할 수 있는 처리량과 관련하여) 성장 한계에 직면하게 된다.

NoSQL의 장점
- 스키마가 없기 때문에, 훨씬 더 유연하다. 즉, 언제든지 저장된 데이터를 조정하고 새로운 '필드'를 추가할 수 있다.
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장된다. 이렇게 하면 데이터를 읽어오는 속도가 빨라진다.
- 수직 및 수평 확장이 가능하므로 데이터베이스가 애플리케이션에서 발생시키는 모든 읽기/쓰기 요청을 처리할 수 있다.

NoSQL의 단점
- 유연성때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수 있다.
- 데이터 중복은 여러 컬렉션과 문서가 (RDB 에서처럼 하나의 테이블에 하나의 레코드가 아니라) 여러 개의 레코드가 변경된 경우 업데이트를 해야 한다.
- 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정(update)를 해야 하는 경우 모든 컬렉션에서 수행해야 함을 의미한다. 

RDB는 언제 사용하는 것이 좋은가?
- 관계를 맺고 있는 데이터가 자주 변경(수정)되는 애플리케이션일 경우
- 변경될 여지고 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

NoSQL은 언제 사용하는 것이 좋은가?
- 정확한 데이터 구조를 알 수 없거나 변경/확장될 수 있는 경우
- 읽기(read) 처리를 자주하지만, 데이터를 자주 변경(update)하지 않는 경우
- 데이터베이스를 수평으로 확장해야 하는 경우 (즉, 막대한 양의 데이터를 다뤄야 하는 경우)

## 5. Cashing
캐시: 한 번 읽어온 데이터를 임의의 공간에 저장하여 다음에 읽을 때는 빠르게 결과값을 받을 수 있도록 도와주는 공간.

그래서 같은 요청이 여러 번 들어오는 경우에는 캐시 서버에서 바로 결과값을 반환해주기 때문에 DB 부하를 줄일 수 있음과 동시에 서비스의 개선도 이룰 수 있다.

클라이언트가 웹서버에 요청을 보내면, 웹서버는 데이터를 DB에서 가져오기 전에 Cache에 데이터가 있는지 확인한다. 캐시서버에 데이터가 있으면, 데이터를 DB에 요청하지 않고 바로바로 클라이언트에 데이터를 반환한다. 이를 cache Hit이라고 한다. 
반대는 cache miss인데, 캐시서버에 데이터가 없으면 DB에 해당 데이터를 요청한다. DB는 사용자가 원하는 데이터를 반환해주고, 웹서버는 반환된 데이터를 다음 사용을 위해 캐시에 저장한 후 클라이언트에 반환한다. 따라서 이후에 같은 요청이 올 때는 cache hit이 발생하는 구조이다.

위의 구조가 대부분의 서비스에서 사용하는 캐시 사용 패턴이다. 이런 구조는 DB를 위한 캐시뿐만 아니라 static한 파일을 캐시해주는 CDN 서비스와도 동일한 구조이다.

### 📌 Redis
Redis: 키-값 기반의 인-메모리 데이터 저장소. 키-값 기반이기 때문에 쿼리를 따로 할 필요없이 결과를 바로 가져올 수 있다. 또한 디스크에 데이터를 쓰는 구조가 아니라 메모리에서 데이터를 처리하기 때문에 속도가 상당히 빠르다. 

다양한 데이터 구조를 지원하는 덕에 redis는 여러 가지 용도로 사용된다. 캐시 데이터 저장은 물론이고, 인증 토큰 저장, ranking board 등으로 자주 사용된다. 이렇게 여러가지 용도로 쓰일 정도로 상당히 좋은 오픈소스이지만 인-메모리 특성상 관리를 잘 해주는 것이 중요하다.

Redis는 single-threaded이다. 즉, 한 번에 딱 하나의 명령어만 실행할 수 있다.

### 📌 Memcached
Memcached: 범용 분산 시스템. 외부 데이터 소스(DB나 API)의 읽기 횟수를 줄이기 위해 데이터와 객체들을 작은 단위의 키-값 형태로 RAM에 캐시 처리함으로써 동적 데이터베이스 기반 웹사이트의 속도를 높이기 위해 종종 사용된다. 

## 6. Authentication

### Cookie 🍪
쿠키: 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일.

정해진 유효시간만큼 브라우저가 종료되어도 인증이 유지된다.
쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.
Response header에 set-cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다.
쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request 시에 Request Header를 넣어서 자동으로 서버에 전송한다.

쿠키의 사용 예)
로그인 시 “아이디와 비밀번호를 저장하시겠습니까?”
쇼핑몰의 장바구니 기능
자동 로그인, 팝업에서 “오늘 더 이상 이 창을 보지 않음” 체크


### Session 📚
세션은 쿠키를 기반으로 하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리한다.
서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다.
물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능하다.
사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다. 즉, 동접자 수가 많은 웹 사이트의 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 된다.
클라이언트가 request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는데 이것이 세션ID다.

세션의 동작 방식
1.	클라이언트가 서버에 접속 시 세션 ID를 발급받습니다.
2.	클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있습니다.
3.	클라리언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용합니다.
4.	서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져옵니다.
5.	클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답합니다.

세션의 특징
* 각 클라이언트에게 고유 ID를 부여
* 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
* 보안 면에서 쿠키보다 우수
* 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

세션의 사용 예)
로그인 같이 보안상 중요한 작업을 수행할 때 사용

### 쿠키와 세션의 차이
* 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문입니다.
* 가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.
* 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.
* 보안, 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다.
* 라이프 사이클, 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다.
* 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
* 속도, 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

#### 세션을 사용하면 좋은데 왜 쿠키를 사용할까?
세션은 서버의 자원을 사용하기때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문이다.


쿠키/세션은 캐시와 엄연히 다르다!
* 캐시는 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것이다.
* 한번 캐시에 저장되면 브라우저를 참고하기 때문에 서버에서 변경이 되어도 사용자는 변경되지 않게 보일 수 있는데 이런 부분을 캐시를 지워주거나 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시하는 방법등을 이용할 수 있다.
* 보통 쿠키와 세션의 차이를 물어볼 때 저장위치와 보안에 대해서는 잘 말하는데 사실 중요한 것은 라이프사이클을 얘기하는 것이다.

### Token

## 7. Distributed System
분산 시스템: 하나의 시스템처럼 보이는 독립된 컴퓨터들의 집합

#### 특징
- 분산 시스템을 구성하는 각 컴퓨팅 요소들이 독립적으로 동작할 수 있다는 것. 이러한 컴퓨팅 요소들을 일반적으로 노드(Node)라고 부르며, 이는 하드웨어 장치나 소프트웨어 프로세스가 될 수 있다.

- 사용자들이 분산 시스템을 다룰 때 단일 시스템을 다루는 것처럼 느낀다는 것. 이것은 각 노드들이 다른 노드들과 협업하여 동작하는 방법이 필요하다는 의미. 이러한 협업을 구성하는 것은 분산 시스템 개발의 핵심!


### 📌 CAP theorem
CAP 정리(or 브루어의 정리): 다음과 같은 세 가지 조건을 모두 만족하는 분산 컴퓨터 시스템이 존재하지 않음을 증명한 정리
* 일관성(Consistency): 모든 노드가 같은 순간에 같은 데이터를 볼 수 있다.
* 가용성(Availability): 모든 요청이 성공 또는 실패 결과를 반환할 수 있다.
* 분할 내성(Partition tolerance): 메시지 전달이 실패하거나 시스템 일부가 망가져도 시스템이 계속 동작할 수 있다.

### 📌 BASE 원칙
* Basically Available: 일반적인 R/W에 대한 동작이 가능한만큼 지원된다.
* Soft state: consistency가 보장되지 않기 때문에 상태(state)에 대해 solid하게 정의하지 못한다.
* Eventually consistent: 충분한 시간이 흐르면 모든 시스템 환경 내에서 데이터는 최신의 데이터가 보장된다.

BASE 원칙은 트랜잭션 시스템을 위한 ACID 원칙에 반대된다. 이는 분산 환경에서 나타나는 특징이기 때문이다.