02/22 1차 온보딩

### OKR
objective Key Result
#### KPI: Key Performance Indicator, 핵심성과지표.
### Sprint
* Scrum 방법론
* 3-4주 주기로
* 프로세스 (꼭 이걸 따르진 않음. 유동적)
  - Idea 제안 
  - 방향성 설정 
  - 백로그 수집 
  - 가설 검증(백로그 -> 가설로 변경)
  - 우선순위 설정 
  - 여러 차례의 리뷰 
  - 회의 후 회고 
      
### 모노레포 구조
프로젝트 구조를 구성하는 방식에는 3가지가 있다.
* 모놀리스: 하나의 레포지토리 안에 하나의 패키지 안에 여러 개의 서비스가 폴더로 구분
* 멀티레포: 하나의 레포 안에 하나의 패키지 안에 하나의 서비스가 들어감.
* 모노레포: 하나의 레포 안에 큰 공통 패키지 하나 안에 여러 개의 서브 패키지(서비스)들이 들어감.

#### 모노레포의 장점
패키지별로 배포하기 쉬워진다.
의존성 관리가 간편해진다.
이슈 관리가 간편해진다.
각 서브 패키지가 독립적이면서, 서로를 공유할 수 있다.
#### 단점
레포가 너무 커진다. 그래서 모노레포를 도와주기 위한 툴을 사용하기도 한다.

### Babel
Babel은 ECMAScript 2015+ 코드를 이전 JavaScript 엔진에서 실행할 수있는 이전 버전과 호환되는 JavaScript 버전으로 변환하는 데 주로 사용되는 무료 오픈 소스 JavaScript **트랜스 컴파일러**

IE6에서는 ES5도 잘 지원 안했음. IE11도 최대가 ES5+
#### 트랜스 컴파일러: source to source compiler, 변환기, 프로그램의 소스 코드(즉, 이미 컴파일된 소스를 다른 언어로 변환하는 특별한 유형의 컴파일러. 이전 버전의 프로그래밍 언어로 작성된 프로그램을 처리하고 동일한 언어의 최신 버전으로 변환하는 데에도 사용할 수 있다.
#### 컴파일러 요소
* Parser: lexical analyze 되어 토큰화된 데이터를 가지고 그것을 구조적으로 나타낼 수 있게 해준다. 또한, 데이터를 구조적으로 바꾸는 과정에서 데이터가 올바른지 검증을 수행한다. 대부분의 인터프리터와 컴파일러에서 소스코드를 구조적으로 나타내는 자료구조로 AST를 사용한다.
* Tokenizer, Lexer: 토크나이저란 어떤 구문에서 의미있는 요소들을 토큰으로 쪼개는 역할을 하고 렉서는 토큰의 의미를 분석하는 역할을 한다. Tokenizer, Lexer의 역할을 합하여 Lexical analyze라고 한다. Lexical Analyze란 의미 있는 조각을 검출하여 토큰을 생성하는 것을 말한다. 예를 들어, Lexical analysis is the first step of compiler"라는 문장에서 'L', 'e', 'x', 'i', 'c', 'a', 'l'을 따로 놓으면 어떠한 의미도 없지만, "Lexical"이라는 하나의 조각으로 보면 의미를 갖게 된다. 이렇게 토큰 단위로 키워드나 속성을 정의한 이후에 parser에게 넘겨준다.
#### Babel plugin은 babel이 어떤 코드를 어떻게 판단할지에 대한 규칙을 나타낸다.
#### 바벨은 새로운 문법을 파싱할 수 있게 해줌. 파싱하면 트리가 나옴. 이 트리를 가지고 ES5로 만드는 것이 babel이 하는 일
Babel이 소스코드를 이전 환경에 맞게 변환하는 과정은 다음과 같다.
* Parsing: 구문 분석, 소스 코드를 읽어 추상 구문 트리(AST)로 변환하는 단계
* Transformation: 변환, 정해진 규칙대로 추상 구문 트리(AST)에 변형을 가하는 단계
* Printing: 출력, 변형이 가해진 추상 구문 트리(AST)를 다시 코드로 출력

#### AST(Abstract Syntax Tree): 프로그래밍 언어로 작성된 소스 코드의 추상 구문 구조의 트리이다. 이 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타낸다. 구문이 추상적이라는 의미는 실제 구문에서 나타나는 모든 세세한 정보를 나타내지는 않는다는 것을 의미한다.
AST는 컴파일러에 널리 사용되는 자료 구조인데, 이는 프로그램 코드의 구조를 표현하는 프로퍼티이기 때문이다. 일반적으로 컴파일러 구문 분석 단계의 결과물이다. 컴파일러가 요구하는 여러 단계를 통해 프로그램의 중간 표현 역할을 하며 컴파일러의 최종 결과물에 대해 강력한 영향을 준다.

TypeScript를 사용할 때 Babel을 꼭 써야 하는 것은 아니지만 @babel/preset-env가 브라우저 호환성 맞추는데 강력한 도구이기 때문에 꼭 쓰는 것을 추천한다. 지원할 브라우저를 이름이나 점유율로 명시하면 그에 맞는 transform과 polyfill이 자동으로 설정된다.

#### polyfill: 개발자가 특정 기능이 지원되지 않는 브라우저를 위해 사용할 수 있는 코드 조각이나 플러그인을 말한다.
Babel과 polyfill 덕분에 최신 TypeScript(또는 ECMAScript)를 사용하면서도 IE를 지원하는 것이 가능해졌다.

### Webpack
웹팩(Webpack 또는 webpack)은 오픈 소스 자바스크립트(JS) 모듈 번들러이다. 주로 자바스크립트(JS)를 위한 모듈 번들러이지만 호환 플러그인을 포함하는 경우 HTML, CSS, 심지어는 이미지와 같은 프론트엔드 자산들을 변환할 수 있다.

웹팩은 여러 파일을 하나의 파일로 만들어준다.

Js 코드가 많아지면 하나의 파일로 관리하는데 한계가 있다. 그렇다고 여러 개 파일을 브라우저에서 로딩하는 것은 그만큼의 네트워크 비용이 든다. 뿐만 아니라 각 파일은 서로의 스코프를 침범하지 않아야 하는데 잘못 작성할 경우 변수 충돌의 위험성도 있다. 함수 스코프를 사용하는 js는 즉시호출함수(IIFE)를 사용해 모듈을 만들 수 있다. 모듈을 IIFE 스타일로 변경해 주는 과정뿐만 아니라 하나의 파일로 묶어 네트워크 비용을 최소화할 수 있는 방법이 웹 프론트엔드 개발 과정에는 필요하다.
#### 웹팩의 4가지 개념
* entry: 웹팩에서 모든 것은 모듈이다. Js, 스타일시트, 이미지 등 모든 것을 js 모듈로 코딩해서 사용하도록 한다. Js가 로딩하는 모듈이 많아질수록 모듈간의 의존성은 증가한다. 의존성 그래프의 시작점을 웹팩에서는 엔트리라고 한다. 웹팩은 엔트리를 통해서 필요한 모듈을 로딩하고 하나의 파일로 묶는다.
* output: 엔트리에 설정한 js 파일을 시작으로 의존되어 있는 모든 모듈을 하나로 묶을 것이다. 번들된 결과물을 처리할 위치는 output에 기록한다.
* loader: js 파일뿐만 아니라 이미지, 폰트, 스타일시트도 전부 모듈로 관리한다. 그러나 웹팩은 js밖에 모르기 때문에 비js 파일을 웹팩이 이해하게끔 변경해야 하는데 로더가 그런 역할을 한다.
로더는 test와 use 키로 구성된 객체로 설정할 수 있다. 
  - Test에 로딩할 파일을 지정
  - use에 적용할 로더를 설정
  - Babel-loader: es6에서 es5로 변환할 때 바벨을 사용할 수 있는데 test에 es6로 작성한 js 파일을 지정하고, use에 이를 변환할 바벨 로더를 설정한다.
  - Test에 자바스크립트 확장자를 갖는 파일을 정규표현식으로 지정한다. node_modules 폴더는 패키지 폴더이므로 제외하기 위해서 exclude에 설정한다. Exclude에는 제외할 파일 작성
로더를 사용하기 위해서는 노드 패키지로 제공하는 로더를 npm으로 추가.
* 플러그인: 로더가 파일 단위로 처리하는 반면 플러그인은 번들된 결과물을 처리한다. 번들된 자바스크립트를 난독화 한다거나 특정 텍스트를 추출하는 용도로 사용할 수 있다.

+) Next.js는 내부적으로 babel, webpack 모두 가지고 있음
+) Webpack도 transform을 한다. 이미지 transforming -> 이미지 최적화를 어느정도 해줌. (image-webpack-loader)

### 렌더링
렌더링이란 요청해서 서버로부터 받은 내용을 브라우저 화면에 표시하는 것
#### 렌더링 과정
* loader가 서버로부터 정보들을 불러옴
* 파싱을 통해 문서를 DOM 트리로 만든다.
* DOM 트리가 구축되는 동안 브라우저는 렌더 트리를 구축
* CSS 설정 / 레이아웃 위치 지정 
* 렌더링 트리가 그려짐

#### 서버 사이드 렌더링 (SSR): 페이지를 이동할 때마다 새로운 페이지를 요청.
rendering a client-side or universal app to HTML on the server
#### 과정
- Download HTML
- User see Content
#### 장점
* 검색엔진 최적화 가능 -> 서버 사이드 렌더링을 통해 얻을 수 있는 가장 큰 장점
* 성능 개선 -> 첫 렌더링된 html을 클라이언트에게 전달해주기 때문에 초기 로딩 속도를 많이 줄여줄 수 있다. 자바스크립트 파일을 불러오고 렌더링 작업이 완료되기 전에 사용자가 사이트 컨텐츠를 이용할 수 있게 된다.
#### 단점
* 프로젝트의 복잡도
* 페이지 이동 시 화면이 깜빡 거린다.
* 서버 렌더링에 따른 부하가 발생
* 페이지 요청마다 페이지 새로고침이 발생한다.

로그인이 필요없는 페이지는 모두 서버사이드 렌더링 사용 (왜? 인증때문에 그런가?)

+) AWS같은 경우 36분 정도 서버가 죽는다고 함. 그러므로 서버의 이중화 꼭 해주기!!

#### 클라이언트 사이드 렌더링 (CSR): 클라이언트에서 렌더링하는 방식
rendering an app in a browser, generally using the DOM
#### 과정
- Download HTML
- Download JavaScript
- Evaluate JavaScript
- Fetch Data from API
- User see Content
#### 장점
* 첫 요청할 때 한페이지만 불러오게 된다.
* SPA(Single page application): 말 그대로 하나의 페이지로 이루어진 어플리케이션을 의미. 단 하나의 HTML 파일을 기반으로 JS를 이용해 동적으로 화면을 이리저리 컨텐츠를 바꾸는 방식의 웹 어플리케이션
* 그 후, 사용자의 행동에 따른 필요한 부분만 다시 읽어들이기 때문에 서버 측에서 렌더링하여 전체 페이지를 다시 읽어들이는 것보다 빠른 인터렉션을 기대할 수 있다. 즉, 필요한 부분만 리로딩 없이 서버로부터 받아서 화면을 갱신하게 된다.

+) MPA(Multiple Page Application): 화면마다 HTML 파일이 존재하고, 사용자가 그 화면을 요청할 때마다, 웹 서버가 필요한 데이터와 HTML로 파싱해서 보여주는 방식의 웹 어플리케이션.
#### 단점
* 초기 구동 속도가 느리다.
* 검색엔진 최적화가 어렵다. 

### Encoding
사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 만드는 것. 넓은 의미의 컴퓨터는 이러한 신호를 입력받고 처리하는 기계를 뜻하며, 신호 처리 시스템을 통해 이렇게 처리된 정보를 사용자가 이해할 수 있게 된다. 이 신호를 입력하는 인코딩과 문자를 해독하는 디코딩을 하기 위해서는 미리 정해진 기준을 바탕으로 입력과 해독이 처리되어야 하는데, 이를 문자열 세트 또는 문자셋이라고 한다. 초기의 문자열 세트는 ASCII나 EBCDIC이 표준이었으나, 이러한 문자열 세트는 세계 곳곳에 인터넷이 보급되며 표현해야 할 문자가 증가하면서 이러한 문자셋들을 표준화하기 위해 많은 대체 방식이 개발되었다. 

#### 문자 인코딩 형태
특정한 문자 집합 안의 문자들을 컴퓨터 시스템에서 사용할 목적으로 일정한 범위 안의 정수(코드값)들로 변환하는 방법. UTF-8, Unicode 등등

+) EUC-KR: 한글 표현을 위한 인코딩 방법
#### 문자 인코딩 구조
문자 인코딩 형태로 변환된 코드값을 옥텟 기반의 시스템에서 사용하기 위하여 옥텟들로 변환하는 방법. 대부분의 문자 인코딩 형태는 이 과정에서 아무런 일도 일어나지 않으며, 8비트 이상의 숫자를 사용하는 UTF-16과 같은 문자 인코딩 형태의 경우 엔디안을 지정해 주는 것으로 충분하다. 여기에는 ISO 2022와 같은 복합 인코딩이나 SCSU와 같은 압축 방법 등이 속한다. 

#### Endian
컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻하며, 바이트를 배열하는 방법을 특히 바이트 순서라 한다. 
- Little-endian: 작은 단위의 바이트가 앞에 오는 방법.
- Big-endian: 사람이 숫자를 쓰는 방법과 같이 큰 단위의 바이트가 앞에 오는 방법.