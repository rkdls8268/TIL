### DB의 index / compound index
-	데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조. 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다. 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.
-	데이터베이스의 인덱스는 b-tree 구조이다.
#### 인덱스가 필요한 이유
Table full scan을 막기 위해 데이터의 주소록 인덱스를 만들어서 데이터를 관리하는 것이다. 결론적으로 원하는 데이터의 블록 주소(ROWID)를 찾는 개념.

-	일반적으로 select 구문을 통해 데이터 조회를 요청한다. DB 서버 프로세스는 memory(db 버퍼 캐시)를 먼저 확인. 메모리에는 자주 사용되는 테이블이 캐싱 저장(자동으로?) 원하는 데이터가 메모리에 없는 경우 실제 하드 디스크의 데이터 파일에서 복사해 온 다음 리턴  메모리에 데이터가 있어 조회할 경우에는 빠른 쿼리 수행 속도를 보이지만, 원하는 데이터가 없으면 하드의 모든 블록 테이블을 조회한다.(table full scan)

#### 인덱스 기본 원리: 테이블 전체 스캔 - 정렬 - 블록 기록
-	인덱스로 지정한 컬럼(key) 값과 해당 컬럼(key)에 해당하는 ROWID로 구성
-	인덱스가 생성되면 where 절에 해당 컬럼의 인덱스가 생성되어 있으면, 먼저 해당 데이터가 있는 ROWID 부터 검색해서 해당 블록만 가져온다.
##### 인덱스 종류
* B-tree 인덱스: 주로 실시간 처리 시스템에 사용. 일반적으로 아는 tree 구조로 root block이 있고, 그 아래 가지방식으로 branch block, leaf block 형태로 구성, 데이터 값 종류가 많고, 동일한 데이터가 적은 경우 사용
* Unique index: 지정한 컬럼으로 생성한 인덱스의 해당 컬럼 데이터가 중복으로 들어갈 수 없다.
* Non-unique index: 중복된 컬럼이 들어가야하는 테이블의 경우 생성
* 결합 index: 두 개 이상의 컬럼을 합쳐 index 생성. 주로 where 조건절이 2개 이상의 쿼리로 작성된 경우 사용
* 함수 기반 index: 함수 형태로 index 생성
* Bitmap 인덱스

#### 인덱스 주의사항 
- insert 작업에서 테이블에는 차례대로 입력이 되지만, 인덱스에는 데이터가 순서대로 정렬이 되고 입력이 필요하여 성능이 저하될 수 있다. 
- Delete 경우도 테이블에서만 삭제가 되고 인덱스에서는 남아있어 늘어난 데이터로 인한 쿼리 수행 속도 저하가 되기도 한다. 
- Update 또한 인덱스에는 update가 없어 delete, insert 두 작업이 수행되면서 큰 부하를 준다고 한다.

Db의 인덱스는 b-tree 자료구조를 이용하여 테이블의 요소를 빠르게 탐색하도록 설계되어 있다. 
#### 그러면 인덱스는 그 많은 자료구조 중에 왜 하필 b-tree?
우선 b-tree는 밸런스 트리의 대표적인 자료구조이다. 밸런스 트리란 트리의 노드가 한 방향으로 쏠리지 않도록, 노드 삽입 및 삭제 시 특정 규칙에 맞게 재정렬되어 왼쪽과 오른쪽 자식 양쪽 수의 밸런스를 유지하는 트리이다. 항상 양쪽 자식의 밸런스를 유지하므로 무조건 o(logN)의 시간 복잡도를 가지게 된다. 다만 재정렬되는 작업으로 인해 노드 삽입 및 삭제 시 일반적인 트리보다 성능이 떨어지게 된다. 그러므로 밸런스 트리는 삽입/삭제의 성능을 희생하고 탐색에 대한 성능을 높였다고 할 수 있다.

*"탐색 시간이 O(logN)인 자료구조나 알고리즘은 다른 것들도 많지 않나?"*

*"해시 테이블은 O(1)인데, 그러면 차라리 해시 테이블을 쓰는 게 더 빠르지 않나?"*

*"그러면 밸런스 트리 중 B-Tree 말고도 RedBlack-Tree로도 사용할 수 있는 것 아닌가?"*

#### 탐색 시간이 제일 빠른 해시 테이블(o(1))을 db index로 사용할 수 없는 이유?
해시 테이블은 해시 함수를 통해 나온 해시 값을 이용하여 저장된 메모리 공간에 한 번에 접근을 하기 때문에 o(1)이라는 시간 복잡도를 가진다. 물론 해시 충돌 등으로 최악의 경우에는 O(N) 가짐.) 그러나 이는 온전히 단 하나의 데이터를 탐색하는 시간에만 o(1)이다. 우리는 DB에서 등호뿐 아니라 부등호도 사용할 수 있다. 모든 값이 정렬되어 있지 않으므로, 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 수가 없다. 그렇기 때문에 기준 값보다 크거나 작은 요소들을 항상 탐색할 수 있어야 하는 db 인덱스 용도로 해시 테이블은 어울리지 않는 자료구조인 것.

#### 배열을 사용하지 않는 이유? 삽입/삭제에 있어서 매우 비효율적인 성능이 발생하기 때문
새롭게 삽입되는 데이터가 가장 작은 데이터라면, 자리 탐색 시간인 o(logN)과 맨 앞에 새로운 데이터 삽입을 위해 모든 데이터를 한 칸씩 뒤로 이동하는 시간 o(N)으로, 총 O(N*logN)의 시간이 걸리게 된다.

#### 비트리가 가장 적합한 이유
1. 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다. 
2. 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다. 
3. 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 o(logN)의 시간 복잡도를 가진다.

### 컴파운드 인덱스
복합 인덱스. 검색에 여러 키가 사용된다면 이 인덱스 타입으로 정의. 컴파운드 인덱스가 여러 키를 지정할 수 있다고 해서 각각 다른 쿼리에 각각의 키로 검색할 수 있다고 생각하면 안된다. 컴파운드 인덱스를 제대로 이해하기 위해서는 이 부분을 주의깊게 살피고 이해해야 한다.

```
db.students.createIndex({userid: 1, score: -1})
```
-	위의 쿼리에서 학생 컬렉션의 인덱스로 userid와 score가 별개의 데이터 구조를 가지고 있는 것이 아니다. 마치 단일 인덱스처럼 일렬로 나열된 userid 배열의 각 아이템에 score를 담고 있는 것으로 생각할 수 있다.

![compound_index](../images/2019-04-05-index-compound-key.bakedsvg.svg)

-	두 인덱스가 함께 저장되어 있으며, 첫번째 userid는 원하는대로 오름차순의 순서대로 예쁘게 정렬되어 있지만 score는 그렇지 않다. 하지만 자세히 들여다보면 동일한 userid들끼리는 그 안에서 score가 내림차순으로 다시 정렬되어 있는 것을 볼 수 있다. 키로 score를 지정해서 검색을 하면 좋은 효과를 볼 수 있을까? 그림에서처럼 score는 동일한 userid 안에서만 정렬이 되어 있으므로 단독으로 검색을 할 때에는 효율이 좋을 수가 없다. 그런 경우에는 score를 위한 인덱스를 따로 만들어주는 것이 성능에 이점이 있다.
-	컴파운드 인덱스의 핵심은 인덱스로 지정한 각각의 필드는 그 순서대로 쿼리문에 나타나야 한다는 것!

### InnoDB
Transaction-safe한 storage engine
- Mysql 5.5 이후 기본적으로 사용되고 있다.
-	MVCC 지원, ACID Transaction 처리, FK 지원, row-level lock 등
-	Undo, Tablespace 등 oracle의 개념을 많이 수용하고 있다.
-	MyISAM 대비 동시처리에 효과적인 구조로 되어 있다. 예를 들어 MyISAM은 table과 index를 각각 다른 파일로 관리하는데 반해 innoDB는 Tablespace 개념을 사용한다.

+) MVCC(Multi-Version Concurrency Control): 다중 버전 동시성 제어
동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나. MVCC 모델에서 데이터에 접근하는 사용자는 접근한 시점에서 데이터베이스의 snapshot을 읽는다. 이 snapshot 데이터에 대한 변경이 완료될 때(트랜잭션이 commit될 때)까지 만들어잔 변경사항은 다른 데이터베이스 사용자가 볼 수 없다. 이제 사용자가 데이터를 업데이트하면 이전의 데이터를 덮어씌우는게 아니라 새로운 버전의 데이터를 undo 영역에 생성한다. 대신 이전 버전의 데이터와 비교해서 변경된 내용을 기록한다. 이렇게 해서 하나의 데이터에 대해 여러 버전의 데이터가 존재하게 되고, 사용자는 마지막 버전의 데이터를 읽게 된다.
- 일반적인 RDBMS보다 매우 빠르게 작동
- 사용하지 않는 데이터가 계속 쌓이게 되므로 데이터를 정리하는 시스템이 필요
- 데이터 버전이 충돌하면 애플리케이션 영역에서 이러한 문제를 해결해야 한다.
  

+) ACID: 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
- Atomicity(원자성): 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장
- consistency(일관성): 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것
- isolation(독립성): 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장
- durability(지속성): 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다는 것

+) Tablespace: 테이블이 저장되는 공간

#### InnoDB 사용 이유 
 * 대용량의 데이터를 컨트롤하는 경우
 * 트랜잭션 관리가 필요한 경우
 * 복구가 필요할 경우
 * 정렬 등의 구문이 들어가는 경우
 * IUD 등이 빈번하게 발생하는 경우
 * 높은 퍼포먼스가 필요한 대용량 사이트에 적합

#### 장점
 * 데이터 무결성이 보장
 * 동시성 제어가 가능
 * 제약조건, 외래키 생성이 가능
 * Row-level lock(행 단위 lock)을 사용하기 때문에 변경 작업(insert, update, delete)에 대한 속도가 빠름
 * 트랜잭션을 지원해 transaction-safe 테이블 관리
 * MyISAM과 비슷하지만 oracle처럼 많은 기능을 지원(commit, rollback, 장애 복구, row-level locking, 외래키 등 다양한 기능을 지원)
#### 단점
 * 복구 방법 어려움
 * Dead lock 발생 가능성 있음
 * 여러 기능이 존재하므로 모델 디자인 시간 증가
 * 시스템 자원을 많이 차지함
 * Full-text 인덱싱이 불가능

#### VARCHAR, TEXT 관련형

|자료형|변함 여부|내용|비고|
|---|---|---|---|
|VARCHAR(M)	|가변	|1~255 까지 가변길이, 문자길이 + 1byte	| 적은 용량|
| TEXT	| 가변	| ~ 65535 |	문자데이터 저장 유리 | 

되도록이면 TEXT보다는 VARCHAR 사용해주는게 메모리에 좋음.

CHAR형은 용량은 많이 차지하지만 검색에 유리하고, VARCHAR형은 용량은 적게 차지하지만 검색에서 불리하다.
- 회원 정보를 예로 들자면, 검색을 많이 하고 비교적 일정한 길이의 아이디 같은 경우 CHAR형으로 저장하고, 이메일같이 길이가 유동적이고 검색을 별로 하지 않는 데이터의 경우 varchar형으로 저장하는 것이 좋음. (실제 두 형의 체감 검색 속도 차이는 별로 없지만, 데이터가 많아지면 얘기가 달라진다!!)

항상 DB 설계를 할 때 어떠한 자료형을 쓸 것인가에 대해 고민을 많이 하는 것이 좋다. 저장될 데이터에 따른 정확한 자료형 선택이 DB의 속도와 효율성을 크게 좌우하기 때문이다!!
